/**
 * Some code is generated by AI and adopted by repo's author.
 */;

/**
 * Normalise angle in radian to `-pi` to `pi` range.
 */
export function normaliseRadian(radian_degree: number)
{
    let normalised = radian_degree % (2 * Math.PI)
    if (normalised > Math.PI) { normalised -= 2 * Math.PI }
    else if (normalised < -Math.PI) { normalised += 2 * Math.PI }

    return normalised
}

/**
 * Maps a linear input value from the range [a, b] to a value 
 * in the exponential range [exp_min, exp_max].
 * 
 * @param x The linear input value (must be between a and b).
 * @param a The start of the linear input range.
 * @param b The end of the linear input range.
 * @param exp_min The minimum value of the exponential output range.
 * @param exp_max The maximum value of the exponential output range.
 * @param base The base of the exponential curve (e.g., 10 for standard log10 curve). 
 * A higher base makes the curve steeper towards the max value.
 * @returns The exponentially mapped value.
 * 
 * @author Gemini
 */
export function mapLinearToExp(
    x: number,
    a: number,
    b: number,
    exp_min: number,
    exp_max: number,
    base: number = Math.E
): number
{
    // 1. Normalize x to the [0, 1] range:
    // (x - a) / (b - a)
    const normalized_linear = (x - a) / (b - a);

    // 2. Adjust the base for the desired curve shape. 
    // We use a base 'c' such that c^0 = 1 and c^1 = base.
    const c = base;

    // 3. Apply the exponent to the normalized value:
    // c^normalized_linear
    const exp_result_normalized = Math.pow(c, normalized_linear);

    // 4. Scale and Shift the result to the target range [exp_min, exp_max]
    // The curve now runs from c^0=1 to c^1=base. We need to rescale it.

    // Calculate the total range span (ΔY)
    const exp_range_span = exp_max - exp_min;

    // Calculate the total span of the exponential function (ΔE)
    const exp_function_span = base - 1; // Since c^1=base and c^0=1

    // Rescale: ((c^normalized_linear) - 1) / (base - 1)
    const final_normalized = (exp_result_normalized - 1) / exp_function_span;

    // Shift: exp_min + final_normalized * exp_range_span
    const final_value = exp_min + final_normalized * exp_range_span;

    return final_value;
}

/**
 * Maps a linear input value from the range [a, b] to a corresponding 
 * linear value in the target range [c, d].
 * 
 * @param x The linear input value (ideally between a and b).
 * @param a The start of the linear input range (Source Min).
 * @param b The end of the linear input range (Source Max).
 * @param c The start of the linear output range (Target Min).
 * @param d The end of the linear output range (Target Max).
 * @returns The linearly mapped value.
 * 
 * @author Gemini
 */
export function mapLinearToLinear(
    x: number,
    a: number,
    b: number,
    c: number,
    d: number
): number
{
    // The core formula for linear mapping is:
    // Output = TargetMin + (TargetSpan) * (NormalizedInput)

    // 1. Calculate the Normalized Input (P):
    // This scales x from [a, b] to a dimensionless proportion P in the [0, 1] range.
    // P = (x - a) / (b - a)
    const normalized_input_proportion = (x - a) / (b - a);

    // 2. Calculate the Target Span (ΔT):
    // The total size of the output range.
    const target_span = d - c;

    // 3. Apply the proportion and shift to the target range:
    // Output = c + (P * target_span)
    const final_value = c + (normalized_input_proportion * target_span);

    return final_value;
}

/**
 * Calculates the Greatest Common Divisor (GCD) of two non-negative integers 
 *  using the Euclidean Algorithm.
 * 
 * @param a The first integer.
 * @param b The second integer.
 * @returns The GCD of a and b.
 * 
 * @author Gemini
 */
export function gcd(a: number, b: number): number
{
    // Ensure inputs are non-negative and handle the base case.
    a = Math.abs(a);
    b = Math.abs(b);

    // The Euclidean Algorithm: gcd(a, b) = gcd(b, a % b)
    while (b)
    {
        [a, b] = [b, a % b];
    }
    return a;
}

/**
 * Calculates the Least Common Multiple (LCM) of two non-negative integers 
 *  by using the formula: LCM(a, b) = |a * b| / GCD(a, b).
 * 
 * @param a The first integer.
 * @param b The second integer.
 * @returns The LCM of a and b.
 * 
 * @author Gemini
 */
export function lcm(a: number, b: number): number
{
    // Handle the case where either a or b is zero.
    if (a === 0 || b === 0)
    {
        return 0;
    }

    // Use the GCD function to calculate the LCM
    // Note: The Math.abs ensures a positive result.
    return Math.abs(a * b) / gcd(a, b);
}

export function logByN(base_n: number, x: number)
{
    return Math.log(x) / Math.log(base_n)
}

/**
 * Convert the number into a array, representing the digit from most significant to least.
 */
export function convertDecToSexaDigits(number: number)
{
    let digits: number[] = []
    let current_digit: number = 0

    do
    {
        current_digit = number % 60
        digits.push(current_digit)
        number = Math.floor(number / 60)
    }
    while (number > 0)

    return digits.toReversed()
}

export function generateRandomNumberOfRange(min: number, max: number)
{
    return Math.random() * (max - min) + min
}

/**
 * Generates a skewed random number, favoring the minimum (Min-Side).
 * Authored by Gemini.
 *
 * The bias strength is adjusted by the 'exponent' parameter (must be > 1).
 *
 * @param min - The minimum value of the range (e.g., 1).
 * @param max - The maximum value of the range (e.g., 16).
 * @param exponent - The strength of the skew (e.g., 3.0 for strong skew towards min).
 * @returns An integer value in the range [min, max], with values closer to 'min' being more likely.
 * 
 * @author Gemini
 */
export function generateRandomNumberSkewedMin(min: number, max: number, exponent: number): number
{
    // 1. Get a standard uniform random number (0.0 to 1.0)
    const uniform = Math.random();

    // 2. Apply the power law to skew the value towards 0.
    // Since exponent > 1, the result R will be closer to 0 more often.
    const R = Math.pow(uniform, exponent);

    // 3. Linearly map the skewed random number R (0.0 to 1.0) to the [min, max] range.
    const mappedValue = min + R * (max - min);

    // 4. Round to the nearest integer.
    return Math.round(mappedValue);
}

/**
 * Return `true` or `false` at 50% possibility.
 */
export function coin()
{
    return Math.random() < 0.5
}

export function getWeightedChoice<EleType>(from_array: ArrayLike<EleType>, weight_array: ArrayLike<number>)
{
    let sum = 0
    for (let i = 0; i < weight_array.length; i++) { sum += weight_array[i] }

    const random_number = generateRandomNumberOfRange(0, sum)
    let index = 0
    let acc = 0
    do
    {
        acc += weight_array[index]
        index++
    }
    while (acc < random_number)

    // Index will be greater than the actual range being tested.
    return from_array[index - 1]
}