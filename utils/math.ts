/**
 * Some code is generated by AI and adopted by repo's author.
 */;

/**
 * Normalise angle in radian to `-pi` to `pi` range.
 */
export function normaliseRadian(radian_degree: number)
{
    let normalised = radian_degree % (2 * Math.PI)
    if (normalised > Math.PI) { normalised -= 2 * Math.PI }
    else if (normalised < -Math.PI) { normalised += 2 * Math.PI }

    return normalised
}

/**
 * Maps a linear input value from the range [a, b] to a value 
 * in the exponential range [exp_min, exp_max].
 * @param x The linear input value (must be between a and b).
 * @param a The start of the linear input range.
 * @param b The end of the linear input range.
 * @param exp_min The minimum value of the exponential output range.
 * @param exp_max The maximum value of the exponential output range.
 * @param base The base of the exponential curve (e.g., 10 for standard log10 curve). 
 * A higher base makes the curve steeper towards the max value.
 * @returns The exponentially mapped value.
 * 
 * @author Gemini
 */
export function mapLinearToExp(
    x: number,
    a: number,
    b: number,
    exp_min: number,
    exp_max: number,
    base: number = Math.E
): number
{
    // 1. Normalize x to the [0, 1] range:
    // (x - a) / (b - a)
    const normalized_linear = (x - a) / (b - a);

    // 2. Adjust the base for the desired curve shape. 
    // We use a base 'c' such that c^0 = 1 and c^1 = base.
    const c = base;

    // 3. Apply the exponent to the normalized value:
    // c^normalized_linear
    const exp_result_normalized = Math.pow(c, normalized_linear);

    // 4. Scale and Shift the result to the target range [exp_min, exp_max]
    // The curve now runs from c^0=1 to c^1=base. We need to rescale it.

    // Calculate the total range span (ΔY)
    const exp_range_span = exp_max - exp_min;

    // Calculate the total span of the exponential function (ΔE)
    const exp_function_span = base - 1; // Since c^1=base and c^0=1

    // Rescale: ((c^normalized_linear) - 1) / (base - 1)
    const final_normalized = (exp_result_normalized - 1) / exp_function_span;

    // Shift: exp_min + final_normalized * exp_range_span
    const final_value = exp_min + final_normalized * exp_range_span;

    return final_value;
}

/**
 * Convert the number into a array, representing the digit from most significant to least.
 */
export function convertDecToSexaDigits(number: number)
{
    let digits: number[] = []
    let current_digit: number = 0

    do
    {
        current_digit = number % 60
        digits.push(current_digit)
        number = Math.floor(number / 60)
    }
    while (number > 0)

    return digits.toReversed()
}

export function generateRandomNumberOfRange(min: number, max: number)
{
    return Math.random() * (max - min) + min
}

/**
 * Return `true` or `false` at 50% possibility.
 */
export function coin()
{
    return Math.random() < 0.5
}