/**
 * This class is not used currently by `MusicalDoublePendulum`.
 * For archive reason, it is not deleted.
 * 
 * Part of the algorithm generated by AI, adopted by repo's author.
 * Notated by `@author` annotation.
 */;

import { MusicalDoublePendulum } from "./MusicalDoublePendulum"


export class Ball
{
    x: number = 0
    y: number = 0
    last_x: number = 0
    last_y: number = 0

    pendulum_ref: MusicalDoublePendulum
    updatePosition__impl: (pendulum: MusicalDoublePendulum) => BallPosition

    updatePosition()
    {
        this.last_x = this.x
        this.last_y = this.y

        const { x, y } = this.updatePosition__impl(this.pendulum_ref)
        this.x = x
        this.y = y
    }

    getPosition(): BallPosition
    {
        return ({ x: this.x, y: this.y })
    }

    getLastPosition(): BallPosition
    {
        return ({ x: this.last_x, y: this.last_y })
    }

    /**
     * Used for debouncing. 
     */
    cooldown_of_detectIfCrossedSegment: number = 0

    default_cooldown_of_detectIfCrossedSegment = 60

    /**
     * Detect if the ball crossed a desinated segment defined by two end-points.
     * 
     * Considering the calculation lag because of `delta`, `cross_identifier_current == 0` (current ball is *on the line*) is considered a cross.
     * 
     * @author Gemini
     */
    detectIfCrossedSegment(x_1: number, y_1: number, x_2: number, y_2: number)
    {
        // Debouncing.
        this.cooldown_of_detectIfCrossedSegment--
        if (this.cooldown_of_detectIfCrossedSegment > 0) { return false }

        /** This represents which side the previous point is. 0 means on the line. */
        const cross_identifier_previous = ((x_2 - x_1) * (this.last_y - y_1)) - ((y_2 - y_1) * (this.last_x - x_1))
        /** This represents which side the current point is. 0 means on the line. */
        const cross_identifier_current = ((x_2 - x_1) * (this.y - y_1)) - ((y_2 - y_1) * (this.x - x_1))

        // When they have different sign or one of them are zero, means cross happens.
        const had_crossed = (cross_identifier_previous * cross_identifier_current < 0) || (cross_identifier_current == 0)
        if (had_crossed) { this.cooldown_of_detectIfCrossedSegment = this.default_cooldown_of_detectIfCrossedSegment }
        return had_crossed
    }

    /**
     * Should let the countdown goes to 0 to test if the ball is really hovering.
     */
    hovering_countdown: number = 10

    detectHovering()
    {

    }


    constructor(
        pendulum_ref: MusicalDoublePendulum,
        updatePosition__impl: (pendulum: MusicalDoublePendulum) => BallPosition
    )
    {
        this.pendulum_ref = pendulum_ref
        this.updatePosition__impl = updatePosition__impl
    }
}

export type BallPosition = {
    x: number
    y: number
}