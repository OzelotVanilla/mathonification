"use client"

import "./page.scss"

import { BabylonianSexagesimalNumber } from "./babylonial_sexagesimal";
import { coin, convertDecToSexaDigits, generateRandomNumberOfRange } from "@/utils/math";
import { Dispatch, SetStateAction, useEffect, useRef, useState } from "react";
import { isClientEnvironment } from "@/utils/env";
import { MicrotonalityPlayer } from "./sound_generate";

const max__on_screen__number = 20
const max__offscreen_percent = 5
const max__dec_number = 215999
/** In millisecond */
const min__play_interval = 800

/**
 * Make many numbers, range from 0 to 215999 (59,59,59),
 *  randomly moving on the screen.
 * When the number move to the center of the screen,
 *  it would be showed as the 60-based number.
 */
export default function SexagesimalPage()
{
    const [center_number, setCenterNumber] = useState(0)
    const [is_started, setWhetherStarted] = useState(false)
    const music_player = useRef<MicrotonalityPlayer>(null)
    const last_play_timestamp = useRef(0)

    const start = () =>
    {
        music_player.current = new MicrotonalityPlayer()
        setWhetherStarted(true)
        music_player.current.resume()
        last_play_timestamp.current = performance.now()  // For first time play.
        setCenterNumber(new Date().getFullYear())
    }
    const trySetCenterNumber = (n: number) =>
    {
        const now = performance.now()
        if (now - last_play_timestamp.current > min__play_interval)
        {
            last_play_timestamp.current = now
            setCenterNumber(n)
        }
    }

    useEffect(() =>
    {
        if (music_player.current == null) { return }
        music_player.current.play(center_number)
    }, [center_number])

    useEffect(() =>
    {
    }, [is_started])

    useEffect(() =>
    {
        // Clean-up.
        return () =>
        {
            music_player.current?.stop()
        }
    }, [])

    return (<div id="sexagesimal">
        {
            is_started
                ? (<>
                    <CenterDecSexaNumber number={center_number} />
                    <MovingDecsPanel trySetCenterNumber={trySetCenterNumber} />
                </>)
                : (<div className="PageCover" onClick={start}>
                    <div className="Text">cunei sound</div>
                </div>)
        }
    </div>
    )
}

/**
 * The number showed in the center area of the page.
 */
function CenterDecSexaNumber({ number }: CenterDecSexaNumber__Params)
{
    let digits = convertDecToSexaDigits(number)

    return (<div className="CenterDecSexaNumber">
        <div className="OriginDecNumber">{number}</div>
        <BabylonianSexagesimalNumber digits={digits} />
        <div className="DecRepr">{digits.join(",")}</div>
    </div>)
}

type CenterDecSexaNumber__Params = {
    number: number
}

function MovingDecsPanel({ trySetCenterNumber }: MovingDecsPanel__Params)
{
    type MovingDec__IDType = string
    const [moving_dec_info_dict, setMovingDecInfoDict] = useState(new Map<MovingDec__IDType, MovingDecInfo>())
    const [window_width, setWindowWidth] = useState(isClientEnvironment() ? window.innerWidth : 0)
    const [window_height, setWindowHeight] = useState(isClientEnvironment() ? window.innerHeight : 0)
    /**
     * Generate dec number offscreen until reach `max__on_screen__number`,
     *  `init_x` and `init_y less than `max__offscreen_percent` plus width/height from the screen.
     */
    const tryGenerate = () =>
    {
        setMovingDecInfoDict(d =>
        {
            if (d.size >= max__on_screen__number) { return d }

            let init_x: number, init_y: number, velocity_x: number, velocity_y: number
            let is_fly_to_right = coin()
            let is_fly_to_bottom = coin()

            // Decide where to generate a free coordinate, vertical or horizontal.
            // That is, fix one coord in 100% to 105%, the other one is 0% to 100%.
            if (coin()) // True: make horizontal moveable.
            {
                init_x = generateRandomNumberOfRange(0, window_width)
                init_y = is_fly_to_bottom
                    ? 0 - generateRandomNumberOfRange(0, 0 + max__offscreen_percent / 100) * window_height
                    : window_height + generateRandomNumberOfRange(0, 0 + max__offscreen_percent / 100) * window_height
            }
            else // False: make vertical moveable.
            {
                init_y = generateRandomNumberOfRange(0, window_height)
                init_x = is_fly_to_right
                    ? 0 - generateRandomNumberOfRange(0, 0 + max__offscreen_percent / 100) * window_width
                    : window_width + generateRandomNumberOfRange(0, 0 + max__offscreen_percent / 100) * window_width
            }

            /** region: This part is generated by AI (Gemini). */
            // Define a target area in the middle of the screen (e.g., inner 40% of screen)
            // This ensures they cross "near" the center but not exactly the same pixel every time.
            const target_x = generateRandomNumberOfRange(window_width * 0.25, window_width * 0.75)
            const target_y = generateRandomNumberOfRange(window_height * 0.3, window_height * 0.7)

            // Calculate the difference between Target and Start
            const delta_x = target_x - init_x
            const delta_y = target_y - init_y

            // Calculate the angle (in radians)
            const angle = Math.atan2(delta_y, delta_x)

            // Define speed
            const speed = generateRandomNumberOfRange(40, 80)

            // Apply speed to the calculated angle
            velocity_x = Math.cos(angle) * speed
            velocity_y = Math.sin(angle) * speed
            /** endregion: AI generated part end. */

            let new_d = new Map(d)
            new_d.set(crypto.randomUUID(), ({
                init_x, init_y, velocity_x, velocity_y,
                dec_number: Math.floor(generateRandomNumberOfRange(0, max__dec_number)),
            }) satisfies MovingDecInfo)

            return new_d
        })

        // Try generate more.
        setTimeout(tryGenerate, 1000)
    }
    const onDecCollidingWithCenter = (dec_number: number) => () =>
    {
        trySetCenterNumber(dec_number)
    }
    const onRemoveMovingDec = (moving_dec__id: MovingDec__IDType) => () =>
    {
        setMovingDecInfoDict(d => { d.delete(moving_dec__id); return d })
        tryGenerate()
    }
    const onWindowResize = () =>
    {
        setWindowWidth(window.innerWidth)
        setWindowHeight(window.innerHeight)
    }

    // Init.
    useEffect(() =>
    {
        window.addEventListener("resize", onWindowResize)
        tryGenerate()
    }, [])

    return (<div className="MovingDecsPanel">
        {[...moving_dec_info_dict.entries()].map(([moving_dec__id, info]) => (
            <MovingDec
                key={moving_dec__id}
                init_x={info.init_x} init_y={info.init_y} velocity_x={info.velocity_x} velocity_y={info.velocity_y}
                dec_number={info.dec_number}
                window_height={window_height} window_width={window_width}
                doOnCollidingAction={onDecCollidingWithCenter(info.dec_number)}
                doSelfRemoveAction={onRemoveMovingDec(moving_dec__id)} />
        ))}
    </div>)
}

type MovingDecsPanel__Params = {
    trySetCenterNumber: (n: number) => any
}

type MovingDecInfo = {
    init_x: number
    init_y: number
    velocity_x: number
    velocity_y: number
    dec_number: number
}

function MovingDec({
    init_x, init_y, velocity_x, velocity_y,
    window_width, window_height, dec_number,
    doOnCollidingAction, doSelfRemoveAction
}: MovingDec__Params)
{
    const [is_paused, setIsPaused] = useState(false)

    const dom_ref = useRef<HTMLDivElement>(null)
    const request_anime__id = useRef(0)
    const is_alive = useRef(true)
    let width_percent__store = useRef(init_x / window_width)
    let height_percent__store = useRef(init_y / window_height)
    let is_already_collided = useRef(false)

    const onMouseHoverStart = () =>
    {
        setIsPaused(true)
    }
    const onMouseHoverEnd = () =>
    {
        setIsPaused(false)
    }
    const onClick = () =>
    {
        // Maybe should still let it collide again ?
        // is_already_collided.current = true
        doOnCollidingAction()
    }

    // Init.
    useEffect(() =>
    {
        let last_timestamp = 0

        const update = (timestamp: number) =>
        {
            if (!is_alive.current || is_paused || dom_ref.current == null) { return }
            const delta_in_seconds = Math.min(50, timestamp - last_timestamp) / 1000
            last_timestamp = timestamp

            // Calculate movement.
            width_percent__store.current += (delta_in_seconds * velocity_x) / window_width
            height_percent__store.current += (delta_in_seconds * velocity_y) / window_height
            const width_percent = width_percent__store.current
            const height_percent = height_percent__store.current

            // Check if already far from screen ?
            if (Math.abs(width_percent) > 1.1 || Math.abs(height_percent) > 1.1)
            {
                doSelfRemoveAction()
                return
            }

            // Update position (and redraw).
            dom_ref.current!.style.transform = `translate(${width_percent * window_width}px, ${height_percent * window_height}px)`

            // Check if collide with center ?
            if (!is_already_collided.current
                && 0.4 < width_percent && width_percent < 0.6
                && 0.45 < height_percent && height_percent < 0.55)
            {
                is_already_collided.current = true
                doOnCollidingAction()
            }

            request_anime__id.current = requestAnimationFrame(update)
        }

        is_alive.current = true
        request_anime__id.current = requestAnimationFrame(update)

        // Clean-up.
        return () =>
        {
            is_alive.current = false
            cancelAnimationFrame(request_anime__id.current)
        }
    }, [is_paused])

    return (<div className="MovingDec" ref={dom_ref}
        onMouseEnter={onMouseHoverStart} onMouseLeave={onMouseHoverEnd} onClick={onClick}>
        <div className="InnerText">{dec_number}</div>
    </div>)
}

type MovingDec__Params = MovingDecInfo & {
    window_width: number
    window_height: number
    doSelfRemoveAction: () => any
    doOnCollidingAction: () => any
}